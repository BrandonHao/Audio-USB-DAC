
DAC_FIRMWARE.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000d64  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  20400000  00400d64  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000198  20400050  00400db4  00020050  2**2
                  ALLOC
  3 .debug_info   00017e63  00000000  00000000  00020050  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 000009b9  00000000  00000000  00037eb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000168  00000000  00000000  0003886c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_ranges 00000100  00000000  00000000  000389d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_macro  0002f866  00000000  00000000  00038ad4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002342  00000000  00000000  0006833a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0010a7a5  00000000  00000000  0006a67c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      000000a6  00000000  00000000  00174e21  2**0
                  CONTENTS, READONLY
 11 .ARM.attributes 0000002e  00000000  00000000  00174ec7  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000003f8  00000000  00000000  00174ef8  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00000160  00000000  00000000  001752f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <vectors>:
  400000:	00 00 44 20 39 04 40 00 c1 04 40 00 c1 04 40 00     ..D 9.@...@...@.
  400010:	c1 04 40 00 c1 04 40 00 c1 04 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	c1 04 40 00 c1 04 40 00 00 00 00 00 c1 04 40 00     ..@...@.......@.
  40003c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40004c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40005c:	41 01 40 00 c1 04 40 00 00 00 00 00 c1 04 40 00     A.@...@.......@.
  40006c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40007c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40008c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40009c:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  4000ac:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  4000bc:	c1 04 40 00 c1 04 40 00 c1 04 40 00 29 0c 40 00     ..@...@...@.).@.
  4000cc:	c1 04 40 00 00 00 00 00 c1 04 40 00 00 00 00 00     ..@.......@.....
  4000dc:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  4000ec:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  4000fc:	c1 04 40 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ..@...@...@...@.
  40010c:	c1 04 40 00 c1 04 40 00 00 00 00 00 00 00 00 00     ..@...@.........
  40011c:	00 00 00 00 c1 04 40 00 c1 04 40 00 c1 04 40 00     ......@...@...@.
  40012c:	c1 04 40 00 c1 04 40 00 00 00 00 00 c1 04 40 00     ..@...@.......@.
  40013c:	c1 04 40 00                                         ..@.

00400140 <irq_handler_uart0>:

uint8_t uart_buf[257];
uint8_t *curr_index;
uint16_t data_size;

void irq_handler_uart0(void){
  400140:	b480      	push	{r7}
  400142:	af00      	add	r7, sp, #0
    if(curr_index - uart_buf == data_size){
  400144:	4b0d      	ldr	r3, [pc, #52]	; (40017c <irq_handler_uart0+0x3c>)
  400146:	681b      	ldr	r3, [r3, #0]
  400148:	4a0d      	ldr	r2, [pc, #52]	; (400180 <irq_handler_uart0+0x40>)
  40014a:	1a9b      	subs	r3, r3, r2
  40014c:	4a0d      	ldr	r2, [pc, #52]	; (400184 <irq_handler_uart0+0x44>)
  40014e:	8812      	ldrh	r2, [r2, #0]
  400150:	4293      	cmp	r3, r2
  400152:	d104      	bne.n	40015e <irq_handler_uart0+0x1e>
        UART0->UART_IDR.bit.TXRDY = 1;
  400154:	4a0c      	ldr	r2, [pc, #48]	; (400188 <irq_handler_uart0+0x48>)
  400156:	68d3      	ldr	r3, [r2, #12]
  400158:	f043 0302 	orr.w	r3, r3, #2
  40015c:	60d3      	str	r3, [r2, #12]
    }
    UART0->UART_THR.bit.TXCHR = *(curr_index++);
  40015e:	4b07      	ldr	r3, [pc, #28]	; (40017c <irq_handler_uart0+0x3c>)
  400160:	681b      	ldr	r3, [r3, #0]
  400162:	1c5a      	adds	r2, r3, #1
  400164:	4905      	ldr	r1, [pc, #20]	; (40017c <irq_handler_uart0+0x3c>)
  400166:	600a      	str	r2, [r1, #0]
  400168:	4a07      	ldr	r2, [pc, #28]	; (400188 <irq_handler_uart0+0x48>)
  40016a:	7819      	ldrb	r1, [r3, #0]
  40016c:	69d3      	ldr	r3, [r2, #28]
  40016e:	f361 0307 	bfi	r3, r1, #0, #8
  400172:	61d3      	str	r3, [r2, #28]
}
  400174:	bf00      	nop
  400176:	46bd      	mov	sp, r7
  400178:	bc80      	pop	{r7}
  40017a:	4770      	bx	lr
  40017c:	20400154 	.word	0x20400154
  400180:	20400050 	.word	0x20400050
  400184:	20400158 	.word	0x20400158
  400188:	400e0800 	.word	0x400e0800

0040018c <uart_init>:

void uart_init(void){
  40018c:	b480      	push	{r7}
  40018e:	af00      	add	r7, sp, #0
    PMC->PMC_PCER0.reg |= PMC_PCER0_PID7;
  400190:	4b10      	ldr	r3, [pc, #64]	; (4001d4 <uart_init+0x48>)
  400192:	691b      	ldr	r3, [r3, #16]
  400194:	4a0f      	ldr	r2, [pc, #60]	; (4001d4 <uart_init+0x48>)
  400196:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40019a:	6113      	str	r3, [r2, #16]
    PIOA->PIO_ABCDSR[0].bit.P10 = 0;
  40019c:	4a0e      	ldr	r2, [pc, #56]	; (4001d8 <uart_init+0x4c>)
  40019e:	6f13      	ldr	r3, [r2, #112]	; 0x70
  4001a0:	f36f 238a 	bfc	r3, #10, #1
  4001a4:	6713      	str	r3, [r2, #112]	; 0x70
    PIOA->PIO_ABCDSR[1].bit.P10 = 1;
  4001a6:	4a0c      	ldr	r2, [pc, #48]	; (4001d8 <uart_init+0x4c>)
  4001a8:	6f53      	ldr	r3, [r2, #116]	; 0x74
  4001aa:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4001ae:	6753      	str	r3, [r2, #116]	; 0x74
    PIOA->PIO_PDR.bit.P10 = 1;
  4001b0:	4a09      	ldr	r2, [pc, #36]	; (4001d8 <uart_init+0x4c>)
  4001b2:	6853      	ldr	r3, [r2, #4]
  4001b4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  4001b8:	6053      	str	r3, [r2, #4]

    UART0->UART_BRGR.reg = 10;
  4001ba:	4b08      	ldr	r3, [pc, #32]	; (4001dc <uart_init+0x50>)
  4001bc:	220a      	movs	r2, #10
  4001be:	621a      	str	r2, [r3, #32]
    UART0->UART_CR.bit.TXEN = 1;
  4001c0:	4a06      	ldr	r2, [pc, #24]	; (4001dc <uart_init+0x50>)
  4001c2:	6813      	ldr	r3, [r2, #0]
  4001c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4001c8:	6013      	str	r3, [r2, #0]
}
  4001ca:	bf00      	nop
  4001cc:	46bd      	mov	sp, r7
  4001ce:	bc80      	pop	{r7}
  4001d0:	4770      	bx	lr
  4001d2:	bf00      	nop
  4001d4:	400e0600 	.word	0x400e0600
  4001d8:	400e0e00 	.word	0x400e0e00
  4001dc:	400e0800 	.word	0x400e0800

004001e0 <uart_write>:

void uart_write(uint8_t *buf, uint8_t size){
  4001e0:	b480      	push	{r7}
  4001e2:	b085      	sub	sp, #20
  4001e4:	af00      	add	r7, sp, #0
  4001e6:	6078      	str	r0, [r7, #4]
  4001e8:	460b      	mov	r3, r1
  4001ea:	70fb      	strb	r3, [r7, #3]
    uint8_t i = 0;
  4001ec:	2300      	movs	r3, #0
  4001ee:	73fb      	strb	r3, [r7, #15]
    for(; i < size; i++){
  4001f0:	e00a      	b.n	400208 <uart_write+0x28>
        *(uart_buf + i) = *(buf + i);
  4001f2:	7bfb      	ldrb	r3, [r7, #15]
  4001f4:	687a      	ldr	r2, [r7, #4]
  4001f6:	441a      	add	r2, r3
  4001f8:	7bfb      	ldrb	r3, [r7, #15]
  4001fa:	4924      	ldr	r1, [pc, #144]	; (40028c <uart_write+0xac>)
  4001fc:	440b      	add	r3, r1
  4001fe:	7812      	ldrb	r2, [r2, #0]
  400200:	701a      	strb	r2, [r3, #0]
    for(; i < size; i++){
  400202:	7bfb      	ldrb	r3, [r7, #15]
  400204:	3301      	adds	r3, #1
  400206:	73fb      	strb	r3, [r7, #15]
  400208:	7bfa      	ldrb	r2, [r7, #15]
  40020a:	78fb      	ldrb	r3, [r7, #3]
  40020c:	429a      	cmp	r2, r3
  40020e:	d3f0      	bcc.n	4001f2 <uart_write+0x12>
    }
    *(uart_buf + i + 1) = '\r';
  400210:	7bfb      	ldrb	r3, [r7, #15]
  400212:	3301      	adds	r3, #1
  400214:	4a1d      	ldr	r2, [pc, #116]	; (40028c <uart_write+0xac>)
  400216:	4413      	add	r3, r2
  400218:	220d      	movs	r2, #13
  40021a:	701a      	strb	r2, [r3, #0]
    *(uart_buf + i + 2) = '\n';
  40021c:	7bfb      	ldrb	r3, [r7, #15]
  40021e:	3302      	adds	r3, #2
  400220:	4a1a      	ldr	r2, [pc, #104]	; (40028c <uart_write+0xac>)
  400222:	4413      	add	r3, r2
  400224:	220a      	movs	r2, #10
  400226:	701a      	strb	r2, [r3, #0]
    data_size = size + 2;
  400228:	78fb      	ldrb	r3, [r7, #3]
  40022a:	b29b      	uxth	r3, r3
  40022c:	3302      	adds	r3, #2
  40022e:	b29a      	uxth	r2, r3
  400230:	4b17      	ldr	r3, [pc, #92]	; (400290 <uart_write+0xb0>)
  400232:	801a      	strh	r2, [r3, #0]
    curr_index = uart_buf;
  400234:	4b17      	ldr	r3, [pc, #92]	; (400294 <uart_write+0xb4>)
  400236:	4a15      	ldr	r2, [pc, #84]	; (40028c <uart_write+0xac>)
  400238:	601a      	str	r2, [r3, #0]

    UART0->UART_THR.bit.TXCHR = *(curr_index++);
  40023a:	4b16      	ldr	r3, [pc, #88]	; (400294 <uart_write+0xb4>)
  40023c:	681b      	ldr	r3, [r3, #0]
  40023e:	1c5a      	adds	r2, r3, #1
  400240:	4914      	ldr	r1, [pc, #80]	; (400294 <uart_write+0xb4>)
  400242:	600a      	str	r2, [r1, #0]
  400244:	4a14      	ldr	r2, [pc, #80]	; (400298 <uart_write+0xb8>)
  400246:	7819      	ldrb	r1, [r3, #0]
  400248:	69d3      	ldr	r3, [r2, #28]
  40024a:	f361 0307 	bfi	r3, r1, #0, #8
  40024e:	61d3      	str	r3, [r2, #28]
    while(!UART0->UART_SR.bit.TXRDY);
  400250:	bf00      	nop
  400252:	4b11      	ldr	r3, [pc, #68]	; (400298 <uart_write+0xb8>)
  400254:	695b      	ldr	r3, [r3, #20]
  400256:	f3c3 0340 	ubfx	r3, r3, #1, #1
  40025a:	b2db      	uxtb	r3, r3
  40025c:	2b00      	cmp	r3, #0
  40025e:	d0f8      	beq.n	400252 <uart_write+0x72>
    UART0->UART_THR.bit.TXCHR = *(curr_index++);
  400260:	4b0c      	ldr	r3, [pc, #48]	; (400294 <uart_write+0xb4>)
  400262:	681b      	ldr	r3, [r3, #0]
  400264:	1c5a      	adds	r2, r3, #1
  400266:	490b      	ldr	r1, [pc, #44]	; (400294 <uart_write+0xb4>)
  400268:	600a      	str	r2, [r1, #0]
  40026a:	4a0b      	ldr	r2, [pc, #44]	; (400298 <uart_write+0xb8>)
  40026c:	7819      	ldrb	r1, [r3, #0]
  40026e:	69d3      	ldr	r3, [r2, #28]
  400270:	f361 0307 	bfi	r3, r1, #0, #8
  400274:	61d3      	str	r3, [r2, #28]
    UART0->UART_IER.bit.TXRDY = 1;
  400276:	4a08      	ldr	r2, [pc, #32]	; (400298 <uart_write+0xb8>)
  400278:	6893      	ldr	r3, [r2, #8]
  40027a:	f043 0302 	orr.w	r3, r3, #2
  40027e:	6093      	str	r3, [r2, #8]
  400280:	bf00      	nop
  400282:	3714      	adds	r7, #20
  400284:	46bd      	mov	sp, r7
  400286:	bc80      	pop	{r7}
  400288:	4770      	bx	lr
  40028a:	bf00      	nop
  40028c:	20400050 	.word	0x20400050
  400290:	20400158 	.word	0x20400158
  400294:	20400154 	.word	0x20400154
  400298:	400e0800 	.word	0x400e0800

0040029c <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  40029c:	b480      	push	{r7}
  40029e:	b085      	sub	sp, #20
  4002a0:	af00      	add	r7, sp, #0
  4002a2:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
  4002a4:	687b      	ldr	r3, [r7, #4]
  4002a6:	f003 0307 	and.w	r3, r3, #7
  4002aa:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  4002ac:	4b0b      	ldr	r3, [pc, #44]	; (4002dc <NVIC_SetPriorityGrouping+0x40>)
  4002ae:	68db      	ldr	r3, [r3, #12]
  4002b0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  4002b2:	68ba      	ldr	r2, [r7, #8]
  4002b4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
  4002b8:	4013      	ands	r3, r2
  4002ba:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  4002bc:	68fb      	ldr	r3, [r7, #12]
  4002be:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
  4002c0:	68bb      	ldr	r3, [r7, #8]
  4002c2:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                 |
  4002c4:	4b06      	ldr	r3, [pc, #24]	; (4002e0 <NVIC_SetPriorityGrouping+0x44>)
  4002c6:	4313      	orrs	r3, r2
  4002c8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
  4002ca:	4a04      	ldr	r2, [pc, #16]	; (4002dc <NVIC_SetPriorityGrouping+0x40>)
  4002cc:	68bb      	ldr	r3, [r7, #8]
  4002ce:	60d3      	str	r3, [r2, #12]
}
  4002d0:	bf00      	nop
  4002d2:	3714      	adds	r7, #20
  4002d4:	46bd      	mov	sp, r7
  4002d6:	bc80      	pop	{r7}
  4002d8:	4770      	bx	lr
  4002da:	bf00      	nop
  4002dc:	e000ed00 	.word	0xe000ed00
  4002e0:	05fa0000 	.word	0x05fa0000

004002e4 <sys_init>:
        GPBR->SYS_GPBR[0].reg = 0;
    }
}

//-----------------------------------------------------------------------------
static void sys_init(void) {
  4002e4:	b480      	push	{r7}
  4002e6:	af00      	add	r7, sp, #0

    // Disable watchdog
    WDT->WDT_MR.bit.WDDIS = 1;
  4002e8:	4a34      	ldr	r2, [pc, #208]	; (4003bc <sys_init+0xd8>)
  4002ea:	6853      	ldr	r3, [r2, #4]
  4002ec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4002f0:	6053      	str	r3, [r2, #4]

    // Set flash wait states to maximum for 150 MHz operation
    EFC->EEFC_FMR.reg = EEFC_FMR_FWS(6) | EEFC_FMR_CLOE;
  4002f2:	4b33      	ldr	r3, [pc, #204]	; (4003c0 <sys_init+0xdc>)
  4002f4:	4a33      	ldr	r2, [pc, #204]	; (4003c4 <sys_init+0xe0>)
  4002f6:	601a      	str	r2, [r3, #0]

    PMC->CKGR_MOR.reg = PMC->CKGR_MOR.reg & ~CKGR_MOR_MOSCXTBY;
  4002f8:	4a33      	ldr	r2, [pc, #204]	; (4003c8 <sys_init+0xe4>)
  4002fa:	4b33      	ldr	r3, [pc, #204]	; (4003c8 <sys_init+0xe4>)
  4002fc:	6a1b      	ldr	r3, [r3, #32]
  4002fe:	f023 0302 	bic.w	r3, r3, #2
  400302:	6213      	str	r3, [r2, #32]
    // Enable 12 MHz Xtal
    PMC->CKGR_MOR.reg |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTST(20) | CKGR_MOR_MOSCXTEN;
  400304:	4930      	ldr	r1, [pc, #192]	; (4003c8 <sys_init+0xe4>)
  400306:	4b30      	ldr	r3, [pc, #192]	; (4003c8 <sys_init+0xe4>)
  400308:	6a1a      	ldr	r2, [r3, #32]
  40030a:	4b30      	ldr	r3, [pc, #192]	; (4003cc <sys_init+0xe8>)
  40030c:	4313      	orrs	r3, r2
  40030e:	620b      	str	r3, [r1, #32]
    while (!PMC->PMC_SR.bit.MOSCXTS);
  400310:	bf00      	nop
  400312:	4b2d      	ldr	r3, [pc, #180]	; (4003c8 <sys_init+0xe4>)
  400314:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  400316:	f3c3 0300 	ubfx	r3, r3, #0, #1
  40031a:	b2db      	uxtb	r3, r3
  40031c:	2b00      	cmp	r3, #0
  40031e:	d0f8      	beq.n	400312 <sys_init+0x2e>

    PMC->CKGR_MOR.reg |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  400320:	4929      	ldr	r1, [pc, #164]	; (4003c8 <sys_init+0xe4>)
  400322:	4b29      	ldr	r3, [pc, #164]	; (4003c8 <sys_init+0xe4>)
  400324:	6a1a      	ldr	r2, [r3, #32]
  400326:	4b2a      	ldr	r3, [pc, #168]	; (4003d0 <sys_init+0xec>)
  400328:	4313      	orrs	r3, r2
  40032a:	620b      	str	r3, [r1, #32]
    while (!PMC->PMC_SR.bit.MOSCXTS || !PMC->CKGR_MCFR.bit.MAINFRDY);
  40032c:	bf00      	nop
  40032e:	4b26      	ldr	r3, [pc, #152]	; (4003c8 <sys_init+0xe4>)
  400330:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  400332:	f3c3 0300 	ubfx	r3, r3, #0, #1
  400336:	b2db      	uxtb	r3, r3
  400338:	2b00      	cmp	r3, #0
  40033a:	d0f8      	beq.n	40032e <sys_init+0x4a>
  40033c:	4b22      	ldr	r3, [pc, #136]	; (4003c8 <sys_init+0xe4>)
  40033e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  400340:	f3c3 4300 	ubfx	r3, r3, #16, #1
  400344:	b2db      	uxtb	r3, r3
  400346:	2b00      	cmp	r3, #0
  400348:	d0f1      	beq.n	40032e <sys_init+0x4a>

    // Setup PLL (12 MHz * 25 = 300 MHz)
    PMC->CKGR_PLLAR.reg = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(25 - 1) |
  40034a:	4b1f      	ldr	r3, [pc, #124]	; (4003c8 <sys_init+0xe4>)
  40034c:	4a21      	ldr	r2, [pc, #132]	; (4003d4 <sys_init+0xf0>)
  40034e:	629a      	str	r2, [r3, #40]	; 0x28
        CKGR_PLLAR_PLLACOUNT(0x3f) | CKGR_PLLAR_DIVA(1);
    while (!PMC->PMC_SR.bit.LOCKA);
  400350:	bf00      	nop
  400352:	4b1d      	ldr	r3, [pc, #116]	; (4003c8 <sys_init+0xe4>)
  400354:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  400356:	f3c3 0340 	ubfx	r3, r3, #1, #1
  40035a:	b2db      	uxtb	r3, r3
  40035c:	2b00      	cmp	r3, #0
  40035e:	d0f8      	beq.n	400352 <sys_init+0x6e>

    PMC->PMC_MCKR.reg |= PMC_MCKR_MDIV_PCK_DIV2;
  400360:	4a19      	ldr	r2, [pc, #100]	; (4003c8 <sys_init+0xe4>)
  400362:	4b19      	ldr	r3, [pc, #100]	; (4003c8 <sys_init+0xe4>)
  400364:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  400366:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  40036a:	6313      	str	r3, [r2, #48]	; 0x30
    while (!PMC->PMC_SR.bit.MCKRDY);
  40036c:	bf00      	nop
  40036e:	4b16      	ldr	r3, [pc, #88]	; (4003c8 <sys_init+0xe4>)
  400370:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  400372:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  400376:	b2db      	uxtb	r3, r3
  400378:	2b00      	cmp	r3, #0
  40037a:	d0f8      	beq.n	40036e <sys_init+0x8a>

    PMC->PMC_MCKR.bit.CSS = PMC_MCKR_CSS_PLLA_CLK_Val;
  40037c:	4a12      	ldr	r2, [pc, #72]	; (4003c8 <sys_init+0xe4>)
  40037e:	6b13      	ldr	r3, [r2, #48]	; 0x30
  400380:	2102      	movs	r1, #2
  400382:	f361 0301 	bfi	r3, r1, #0, #2
  400386:	6313      	str	r3, [r2, #48]	; 0x30
    while (!PMC->PMC_SR.bit.MCKRDY);
  400388:	bf00      	nop
  40038a:	4b0f      	ldr	r3, [pc, #60]	; (4003c8 <sys_init+0xe4>)
  40038c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40038e:	f3c3 03c0 	ubfx	r3, r3, #3, #1
  400392:	b2db      	uxtb	r3, r3
  400394:	2b00      	cmp	r3, #0
  400396:	d0f8      	beq.n	40038a <sys_init+0xa6>

    // Enable PIOA, PIOB, PIOC, PIOD and PIOE
    PMC->PMC_PCER0.reg |= PMC_PCER0_PID10 | PMC_PCER0_PID11 | PMC_PCER0_PID12 |
  400398:	4a0b      	ldr	r2, [pc, #44]	; (4003c8 <sys_init+0xe4>)
  40039a:	4b0b      	ldr	r3, [pc, #44]	; (4003c8 <sys_init+0xe4>)
  40039c:	691b      	ldr	r3, [r3, #16]
  40039e:	f443 3347 	orr.w	r3, r3, #203776	; 0x31c00
  4003a2:	6113      	str	r3, [r2, #16]
        PMC_PCER0_PID16 | PMC_PCER0_PID17;

    // Disable altenate functions on some pins
    MATRIX->CCFG_SYSIO.reg |= CCFG_SYSIO_SYSIO4;
  4003a4:	4a0c      	ldr	r2, [pc, #48]	; (4003d8 <sys_init+0xf4>)
  4003a6:	4b0c      	ldr	r3, [pc, #48]	; (4003d8 <sys_init+0xf4>)
  4003a8:	f8d3 3114 	ldr.w	r3, [r3, #276]	; 0x114
  4003ac:	f043 0310 	orr.w	r3, r3, #16
  4003b0:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
}
  4003b4:	bf00      	nop
  4003b6:	46bd      	mov	sp, r7
  4003b8:	bc80      	pop	{r7}
  4003ba:	4770      	bx	lr
  4003bc:	400e1850 	.word	0x400e1850
  4003c0:	400e0c00 	.word	0x400e0c00
  4003c4:	04000600 	.word	0x04000600
  4003c8:	400e0600 	.word	0x400e0600
  4003cc:	00371401 	.word	0x00371401
  4003d0:	01370000 	.word	0x01370000
  4003d4:	20183f01 	.word	0x20183f01
  4003d8:	40088000 	.word	0x40088000

004003dc <NVIC_Initialize>:

static void NVIC_Initialize(void)
{
  4003dc:	b580      	push	{r7, lr}
  4003de:	af00      	add	r7, sp, #0
    /* Priority 0 to 7 and no sub-priority. 0 is the highest priority */
    NVIC_SetPriorityGrouping(0x04);
  4003e0:	2004      	movs	r0, #4
  4003e2:	4b03      	ldr	r3, [pc, #12]	; (4003f0 <NVIC_Initialize+0x14>)
  4003e4:	4798      	blx	r3
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4003e6:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4003ea:	b662      	cpsie	i

    /* Enable NVIC Controller */
    __DMB();
    __enable_irq();
}
  4003ec:	bf00      	nop
  4003ee:	bd80      	pop	{r7, pc}
  4003f0:	0040029d 	.word	0x0040029d

004003f4 <main>:

//-----------------------------------------------------------------------------
int main(void) {
  4003f4:	b580      	push	{r7, lr}
  4003f6:	b082      	sub	sp, #8
  4003f8:	af00      	add	r7, sp, #0
    //full_reset();
    sys_init();
  4003fa:	4b0a      	ldr	r3, [pc, #40]	; (400424 <main+0x30>)
  4003fc:	4798      	blx	r3
    NVIC_Initialize();
  4003fe:	4b0a      	ldr	r3, [pc, #40]	; (400428 <main+0x34>)
  400400:	4798      	blx	r3
    uart_init();
  400402:	4b0a      	ldr	r3, [pc, #40]	; (40042c <main+0x38>)
  400404:	4798      	blx	r3
    uint8_t temp[3] = "abc";
  400406:	4a0a      	ldr	r2, [pc, #40]	; (400430 <main+0x3c>)
  400408:	1d3b      	adds	r3, r7, #4
  40040a:	6812      	ldr	r2, [r2, #0]
  40040c:	4611      	mov	r1, r2
  40040e:	8019      	strh	r1, [r3, #0]
  400410:	3302      	adds	r3, #2
  400412:	0c12      	lsrs	r2, r2, #16
  400414:	701a      	strb	r2, [r3, #0]
    uart_write(temp, 3);
  400416:	1d3b      	adds	r3, r7, #4
  400418:	2103      	movs	r1, #3
  40041a:	4618      	mov	r0, r3
  40041c:	4b05      	ldr	r3, [pc, #20]	; (400434 <main+0x40>)
  40041e:	4798      	blx	r3
    //usb_init();
    while (1) {
  400420:	e7fe      	b.n	400420 <main+0x2c>
  400422:	bf00      	nop
  400424:	004002e5 	.word	0x004002e5
  400428:	004003dd 	.word	0x004003dd
  40042c:	0040018d 	.word	0x0040018d
  400430:	00400c84 	.word	0x00400c84
  400434:	004001e1 	.word	0x004001e1

00400438 <irq_handler_reset>:
};

/*- Implementations ---------------------------------------------------------*/

//-----------------------------------------------------------------------------
void irq_handler_reset(void) {
  400438:	b580      	push	{r7, lr}
  40043a:	b082      	sub	sp, #8
  40043c:	af00      	add	r7, sp, #0
    unsigned int *src, *dst;

    src = &_etext;
  40043e:	4b18      	ldr	r3, [pc, #96]	; (4004a0 <irq_handler_reset+0x68>)
  400440:	607b      	str	r3, [r7, #4]
    dst = &_data;
  400442:	4b18      	ldr	r3, [pc, #96]	; (4004a4 <irq_handler_reset+0x6c>)
  400444:	603b      	str	r3, [r7, #0]
    while (dst < &_edata)
  400446:	e007      	b.n	400458 <irq_handler_reset+0x20>
        *dst++ = *src++;
  400448:	687a      	ldr	r2, [r7, #4]
  40044a:	1d13      	adds	r3, r2, #4
  40044c:	607b      	str	r3, [r7, #4]
  40044e:	683b      	ldr	r3, [r7, #0]
  400450:	1d19      	adds	r1, r3, #4
  400452:	6039      	str	r1, [r7, #0]
  400454:	6812      	ldr	r2, [r2, #0]
  400456:	601a      	str	r2, [r3, #0]
    while (dst < &_edata)
  400458:	683b      	ldr	r3, [r7, #0]
  40045a:	4a13      	ldr	r2, [pc, #76]	; (4004a8 <irq_handler_reset+0x70>)
  40045c:	4293      	cmp	r3, r2
  40045e:	d3f3      	bcc.n	400448 <irq_handler_reset+0x10>

    dst = &_bss;
  400460:	4b12      	ldr	r3, [pc, #72]	; (4004ac <irq_handler_reset+0x74>)
  400462:	603b      	str	r3, [r7, #0]
    while (dst < &_ebss)
  400464:	e004      	b.n	400470 <irq_handler_reset+0x38>
        *dst++ = 0;
  400466:	683b      	ldr	r3, [r7, #0]
  400468:	1d1a      	adds	r2, r3, #4
  40046a:	603a      	str	r2, [r7, #0]
  40046c:	2200      	movs	r2, #0
  40046e:	601a      	str	r2, [r3, #0]
    while (dst < &_ebss)
  400470:	683b      	ldr	r3, [r7, #0]
  400472:	4a0f      	ldr	r2, [pc, #60]	; (4004b0 <irq_handler_reset+0x78>)
  400474:	4293      	cmp	r3, r2
  400476:	d3f6      	bcc.n	400466 <irq_handler_reset+0x2e>

    // Enable FPU
    SCB->CPACR |=  (0xf << 20);
  400478:	4b0e      	ldr	r3, [pc, #56]	; (4004b4 <irq_handler_reset+0x7c>)
  40047a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  40047e:	4a0d      	ldr	r2, [pc, #52]	; (4004b4 <irq_handler_reset+0x7c>)
  400480:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400484:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb");
  400488:	f3bf 8f4f 	dsb	sy
}
  40048c:	bf00      	nop
  __ASM volatile ("isb");
  40048e:	f3bf 8f6f 	isb	sy
}
  400492:	bf00      	nop
    __DSB();
    __ISB();

    SCB->VTOR = (uint32_t)vectors;
  400494:	4b07      	ldr	r3, [pc, #28]	; (4004b4 <irq_handler_reset+0x7c>)
  400496:	4a08      	ldr	r2, [pc, #32]	; (4004b8 <irq_handler_reset+0x80>)
  400498:	609a      	str	r2, [r3, #8]

    main();
  40049a:	4b08      	ldr	r3, [pc, #32]	; (4004bc <irq_handler_reset+0x84>)
  40049c:	4798      	blx	r3

    while (1);
  40049e:	e7fe      	b.n	40049e <irq_handler_reset+0x66>
  4004a0:	00400d64 	.word	0x00400d64
  4004a4:	20400000 	.word	0x20400000
  4004a8:	20400050 	.word	0x20400050
  4004ac:	20400050 	.word	0x20400050
  4004b0:	204001e8 	.word	0x204001e8
  4004b4:	e000ed00 	.word	0xe000ed00
  4004b8:	00400000 	.word	0x00400000
  4004bc:	004003f5 	.word	0x004003f5

004004c0 <irq_handler_dummy>:
}

//-----------------------------------------------------------------------------
void irq_handler_dummy(void) {
  4004c0:	b480      	push	{r7}
  4004c2:	af00      	add	r7, sp, #0
    while (1);
  4004c4:	e7fe      	b.n	4004c4 <irq_handler_dummy+0x4>

004004c6 <handle_aud_ctr_ep>:
#include "usb_aud_ctr.h"

void handle_aud_ctr_ep(void){
  4004c6:	b480      	push	{r7}
  4004c8:	af00      	add	r7, sp, #0
    
}
  4004ca:	bf00      	nop
  4004cc:	46bd      	mov	sp, r7
  4004ce:	bc80      	pop	{r7}
  4004d0:	4770      	bx	lr
  4004d2:	Address 0x004004d2 is out of bounds.


004004d4 <parse_setup_packet>:
    uint16_union_t index;
    uint16_union_t length;
}setup_packet_t;


static setup_packet_t parse_setup_packet(uint8_t ep_num) {
  4004d4:	b480      	push	{r7}
  4004d6:	b085      	sub	sp, #20
  4004d8:	af00      	add	r7, sp, #0
  4004da:	6078      	str	r0, [r7, #4]
  4004dc:	460b      	mov	r3, r1
  4004de:	70fb      	strb	r3, [r7, #3]
    setup_packet_t ret_val = { 0 };
  4004e0:	f107 0308 	add.w	r3, r7, #8
  4004e4:	2200      	movs	r2, #0
  4004e6:	601a      	str	r2, [r3, #0]
  4004e8:	605a      	str	r2, [r3, #4]

    if(endpoints[ep_num].data_len == 0 || ep_num > 10){
  4004ea:	78fa      	ldrb	r2, [r7, #3]
  4004ec:	4917      	ldr	r1, [pc, #92]	; (40054c <parse_setup_packet+0x78>)
  4004ee:	4613      	mov	r3, r2
  4004f0:	009b      	lsls	r3, r3, #2
  4004f2:	4413      	add	r3, r2
  4004f4:	009b      	lsls	r3, r3, #2
  4004f6:	440b      	add	r3, r1
  4004f8:	3310      	adds	r3, #16
  4004fa:	881b      	ldrh	r3, [r3, #0]
  4004fc:	2b00      	cmp	r3, #0
  4004fe:	d002      	beq.n	400506 <parse_setup_packet+0x32>
  400500:	78fb      	ldrb	r3, [r7, #3]
  400502:	2b0a      	cmp	r3, #10
  400504:	d907      	bls.n	400516 <parse_setup_packet+0x42>
        return ret_val;
  400506:	687b      	ldr	r3, [r7, #4]
  400508:	461a      	mov	r2, r3
  40050a:	f107 0308 	add.w	r3, r7, #8
  40050e:	cb03      	ldmia	r3!, {r0, r1}
  400510:	6010      	str	r0, [r2, #0]
  400512:	6051      	str	r1, [r2, #4]
  400514:	e014      	b.n	400540 <parse_setup_packet+0x6c>
    }

    ret_val = *((setup_packet_t *)(endpoints[ep_num].data_buf));
  400516:	78fa      	ldrb	r2, [r7, #3]
  400518:	490c      	ldr	r1, [pc, #48]	; (40054c <parse_setup_packet+0x78>)
  40051a:	4613      	mov	r3, r2
  40051c:	009b      	lsls	r3, r3, #2
  40051e:	4413      	add	r3, r2
  400520:	009b      	lsls	r3, r3, #2
  400522:	440b      	add	r3, r1
  400524:	3308      	adds	r3, #8
  400526:	681a      	ldr	r2, [r3, #0]
  400528:	f107 0308 	add.w	r3, r7, #8
  40052c:	6810      	ldr	r0, [r2, #0]
  40052e:	6851      	ldr	r1, [r2, #4]
  400530:	c303      	stmia	r3!, {r0, r1}

    return ret_val;
  400532:	687b      	ldr	r3, [r7, #4]
  400534:	461a      	mov	r2, r3
  400536:	f107 0308 	add.w	r3, r7, #8
  40053a:	cb03      	ldmia	r3!, {r0, r1}
  40053c:	6010      	str	r0, [r2, #0]
  40053e:	6051      	str	r1, [r2, #4]
}
  400540:	6878      	ldr	r0, [r7, #4]
  400542:	3714      	adds	r7, #20
  400544:	46bd      	mov	sp, r7
  400546:	bc80      	pop	{r7}
  400548:	4770      	bx	lr
  40054a:	bf00      	nop
  40054c:	20400000 	.word	0x20400000

00400550 <send_usb_data>:

static void send_usb_data(const uint8_t ep_num, const uint8_t* buf, uint16_t len) {
  400550:	b480      	push	{r7}
  400552:	b087      	sub	sp, #28
  400554:	af00      	add	r7, sp, #0
  400556:	4603      	mov	r3, r0
  400558:	6039      	str	r1, [r7, #0]
  40055a:	71fb      	strb	r3, [r7, #7]
  40055c:	4613      	mov	r3, r2
  40055e:	80bb      	strh	r3, [r7, #4]
    uint8_t *destination = endpoints[ep_num].fifo_addr;
  400560:	79fa      	ldrb	r2, [r7, #7]
  400562:	494a      	ldr	r1, [pc, #296]	; (40068c <send_usb_data+0x13c>)
  400564:	4613      	mov	r3, r2
  400566:	009b      	lsls	r3, r3, #2
  400568:	4413      	add	r3, r2
  40056a:	009b      	lsls	r3, r3, #2
  40056c:	440b      	add	r3, r1
  40056e:	3304      	adds	r3, #4
  400570:	681b      	ldr	r3, [r3, #0]
  400572:	613b      	str	r3, [r7, #16]
    uint8_t packet_size = endpoints[ep_num].max_packet_size;
  400574:	79fa      	ldrb	r2, [r7, #7]
  400576:	4945      	ldr	r1, [pc, #276]	; (40068c <send_usb_data+0x13c>)
  400578:	4613      	mov	r3, r2
  40057a:	009b      	lsls	r3, r3, #2
  40057c:	4413      	add	r3, r2
  40057e:	009b      	lsls	r3, r3, #2
  400580:	440b      	add	r3, r1
  400582:	330c      	adds	r3, #12
  400584:	881b      	ldrh	r3, [r3, #0]
  400586:	73fb      	strb	r3, [r7, #15]
    uint16_t count = 0;
  400588:	2300      	movs	r3, #0
  40058a:	82fb      	strh	r3, [r7, #22]

    if(len == 0){
  40058c:	88bb      	ldrh	r3, [r7, #4]
  40058e:	2b00      	cmp	r3, #0
  400590:	d172      	bne.n	400678 <send_usb_data+0x128>
        USBHS->USBHS_DEVEPTICR[ep_num].bit.TXINIC = 1;
  400592:	493f      	ldr	r1, [pc, #252]	; (400690 <send_usb_data+0x140>)
  400594:	79fb      	ldrb	r3, [r7, #7]
  400596:	f103 0258 	add.w	r2, r3, #88	; 0x58
  40059a:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  40059e:	f043 0301 	orr.w	r3, r3, #1
  4005a2:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        USBHS->USBHS_DEVEPTIDR[ep_num].bit.FIFOCONC = 1;
  4005a6:	493a      	ldr	r1, [pc, #232]	; (400690 <send_usb_data+0x140>)
  4005a8:	79fb      	ldrb	r3, [r7, #7]
  4005aa:	f103 0288 	add.w	r2, r3, #136	; 0x88
  4005ae:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  4005b2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  4005b6:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        while(!USBHS->USBHS_DEVEPTISR[ep_num].bit.TXINI || (!USBHS->USBHS_DEVEPTIMR[ep_num].bit.FIFOCON && ep_num));
  4005ba:	bf00      	nop
  4005bc:	4a34      	ldr	r2, [pc, #208]	; (400690 <send_usb_data+0x140>)
  4005be:	79fb      	ldrb	r3, [r7, #7]
  4005c0:	334c      	adds	r3, #76	; 0x4c
  4005c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4005c6:	f3c3 0300 	ubfx	r3, r3, #0, #1
  4005ca:	b2db      	uxtb	r3, r3
  4005cc:	2b00      	cmp	r3, #0
  4005ce:	d0f5      	beq.n	4005bc <send_usb_data+0x6c>
  4005d0:	4a2f      	ldr	r2, [pc, #188]	; (400690 <send_usb_data+0x140>)
  4005d2:	79fb      	ldrb	r3, [r7, #7]
  4005d4:	3370      	adds	r3, #112	; 0x70
  4005d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4005da:	f3c3 3380 	ubfx	r3, r3, #14, #1
  4005de:	b2db      	uxtb	r3, r3
  4005e0:	2b00      	cmp	r3, #0
  4005e2:	d14e      	bne.n	400682 <send_usb_data+0x132>
  4005e4:	79fb      	ldrb	r3, [r7, #7]
  4005e6:	2b00      	cmp	r3, #0
  4005e8:	d1e8      	bne.n	4005bc <send_usb_data+0x6c>
        return;
  4005ea:	e04a      	b.n	400682 <send_usb_data+0x132>
    }

    while(count < len){
        for (uint16_t i = 0; i < packet_size && count < len; i++) {
  4005ec:	2300      	movs	r3, #0
  4005ee:	82bb      	strh	r3, [r7, #20]
  4005f0:	e00d      	b.n	40060e <send_usb_data+0xbe>
            *(destination + count) = *(buf + count);
  4005f2:	8afb      	ldrh	r3, [r7, #22]
  4005f4:	683a      	ldr	r2, [r7, #0]
  4005f6:	441a      	add	r2, r3
  4005f8:	8afb      	ldrh	r3, [r7, #22]
  4005fa:	6939      	ldr	r1, [r7, #16]
  4005fc:	440b      	add	r3, r1
  4005fe:	7812      	ldrb	r2, [r2, #0]
  400600:	701a      	strb	r2, [r3, #0]
            count++;
  400602:	8afb      	ldrh	r3, [r7, #22]
  400604:	3301      	adds	r3, #1
  400606:	82fb      	strh	r3, [r7, #22]
        for (uint16_t i = 0; i < packet_size && count < len; i++) {
  400608:	8abb      	ldrh	r3, [r7, #20]
  40060a:	3301      	adds	r3, #1
  40060c:	82bb      	strh	r3, [r7, #20]
  40060e:	7bfb      	ldrb	r3, [r7, #15]
  400610:	b29b      	uxth	r3, r3
  400612:	8aba      	ldrh	r2, [r7, #20]
  400614:	429a      	cmp	r2, r3
  400616:	d203      	bcs.n	400620 <send_usb_data+0xd0>
  400618:	8afa      	ldrh	r2, [r7, #22]
  40061a:	88bb      	ldrh	r3, [r7, #4]
  40061c:	429a      	cmp	r2, r3
  40061e:	d3e8      	bcc.n	4005f2 <send_usb_data+0xa2>
        }
        USBHS->USBHS_DEVEPTICR[ep_num].bit.TXINIC = 1;
  400620:	491b      	ldr	r1, [pc, #108]	; (400690 <send_usb_data+0x140>)
  400622:	79fb      	ldrb	r3, [r7, #7]
  400624:	f103 0258 	add.w	r2, r3, #88	; 0x58
  400628:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  40062c:	f043 0301 	orr.w	r3, r3, #1
  400630:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        USBHS->USBHS_DEVEPTIDR[ep_num].bit.FIFOCONC = 1;
  400634:	4916      	ldr	r1, [pc, #88]	; (400690 <send_usb_data+0x140>)
  400636:	79fb      	ldrb	r3, [r7, #7]
  400638:	f103 0288 	add.w	r2, r3, #136	; 0x88
  40063c:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
  400640:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  400644:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
        while(!USBHS->USBHS_DEVEPTISR[ep_num].bit.TXINI || (!USBHS->USBHS_DEVEPTIMR[ep_num].bit.FIFOCON && ep_num));
  400648:	bf00      	nop
  40064a:	4a11      	ldr	r2, [pc, #68]	; (400690 <send_usb_data+0x140>)
  40064c:	79fb      	ldrb	r3, [r7, #7]
  40064e:	334c      	adds	r3, #76	; 0x4c
  400650:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400654:	f3c3 0300 	ubfx	r3, r3, #0, #1
  400658:	b2db      	uxtb	r3, r3
  40065a:	2b00      	cmp	r3, #0
  40065c:	d0f5      	beq.n	40064a <send_usb_data+0xfa>
  40065e:	4a0c      	ldr	r2, [pc, #48]	; (400690 <send_usb_data+0x140>)
  400660:	79fb      	ldrb	r3, [r7, #7]
  400662:	3370      	adds	r3, #112	; 0x70
  400664:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400668:	f3c3 3380 	ubfx	r3, r3, #14, #1
  40066c:	b2db      	uxtb	r3, r3
  40066e:	2b00      	cmp	r3, #0
  400670:	d102      	bne.n	400678 <send_usb_data+0x128>
  400672:	79fb      	ldrb	r3, [r7, #7]
  400674:	2b00      	cmp	r3, #0
  400676:	d1e8      	bne.n	40064a <send_usb_data+0xfa>
    while(count < len){
  400678:	8afa      	ldrh	r2, [r7, #22]
  40067a:	88bb      	ldrh	r3, [r7, #4]
  40067c:	429a      	cmp	r2, r3
  40067e:	d3b5      	bcc.n	4005ec <send_usb_data+0x9c>
  400680:	e000      	b.n	400684 <send_usb_data+0x134>
        return;
  400682:	bf00      	nop
    }

}
  400684:	371c      	adds	r7, #28
  400686:	46bd      	mov	sp, r7
  400688:	bc80      	pop	{r7}
  40068a:	4770      	bx	lr
  40068c:	20400000 	.word	0x20400000
  400690:	40038000 	.word	0x40038000

00400694 <get_descriptor>:

static void get_descriptor(setup_packet_t* setup) {
  400694:	b580      	push	{r7, lr}
  400696:	b082      	sub	sp, #8
  400698:	af00      	add	r7, sp, #0
  40069a:	6078      	str	r0, [r7, #4]
    switch (setup->value.byte.H) {
  40069c:	687b      	ldr	r3, [r7, #4]
  40069e:	78db      	ldrb	r3, [r3, #3]
  4006a0:	2b03      	cmp	r3, #3
  4006a2:	d024      	beq.n	4006ee <get_descriptor+0x5a>
  4006a4:	2b03      	cmp	r3, #3
  4006a6:	dc61      	bgt.n	40076c <get_descriptor+0xd8>
  4006a8:	2b01      	cmp	r3, #1
  4006aa:	d002      	beq.n	4006b2 <get_descriptor+0x1e>
  4006ac:	2b02      	cmp	r3, #2
  4006ae:	d00f      	beq.n	4006d0 <get_descriptor+0x3c>
  4006b0:	e05c      	b.n	40076c <get_descriptor+0xd8>
    case USB_DEVICE_DESC_TYPE:
        send_usb_data(0, dev_desc,
            setup->length.val_16 > dev_desc_size ?
  4006b2:	687b      	ldr	r3, [r7, #4]
  4006b4:	88da      	ldrh	r2, [r3, #6]
  4006b6:	4b32      	ldr	r3, [pc, #200]	; (400780 <get_descriptor+0xec>)
  4006b8:	781b      	ldrb	r3, [r3, #0]
  4006ba:	b29b      	uxth	r3, r3
        send_usb_data(0, dev_desc,
  4006bc:	4293      	cmp	r3, r2
  4006be:	bf28      	it	cs
  4006c0:	4613      	movcs	r3, r2
  4006c2:	b29b      	uxth	r3, r3
  4006c4:	461a      	mov	r2, r3
  4006c6:	492f      	ldr	r1, [pc, #188]	; (400784 <get_descriptor+0xf0>)
  4006c8:	2000      	movs	r0, #0
  4006ca:	4b2f      	ldr	r3, [pc, #188]	; (400788 <get_descriptor+0xf4>)
  4006cc:	4798      	blx	r3
            dev_desc_size : setup->length.val_16);
        break;
  4006ce:	e053      	b.n	400778 <get_descriptor+0xe4>

    case USB_CFG_DESC_TYPE:
        send_usb_data(0, config_desc,
            setup->length.val_16 > config_desc_size ?
  4006d0:	687b      	ldr	r3, [r7, #4]
  4006d2:	88da      	ldrh	r2, [r3, #6]
  4006d4:	4b2d      	ldr	r3, [pc, #180]	; (40078c <get_descriptor+0xf8>)
  4006d6:	781b      	ldrb	r3, [r3, #0]
  4006d8:	b29b      	uxth	r3, r3
        send_usb_data(0, config_desc,
  4006da:	4293      	cmp	r3, r2
  4006dc:	bf28      	it	cs
  4006de:	4613      	movcs	r3, r2
  4006e0:	b29b      	uxth	r3, r3
  4006e2:	461a      	mov	r2, r3
  4006e4:	492a      	ldr	r1, [pc, #168]	; (400790 <get_descriptor+0xfc>)
  4006e6:	2000      	movs	r0, #0
  4006e8:	4b27      	ldr	r3, [pc, #156]	; (400788 <get_descriptor+0xf4>)
  4006ea:	4798      	blx	r3
            config_desc_size : setup->length.val_16);
        break;
  4006ec:	e044      	b.n	400778 <get_descriptor+0xe4>

    case USB_STR_DESC_TYPE:
        switch (setup->value.byte.L) {
  4006ee:	687b      	ldr	r3, [r7, #4]
  4006f0:	789b      	ldrb	r3, [r3, #2]
  4006f2:	2b02      	cmp	r3, #2
  4006f4:	d024      	beq.n	400740 <get_descriptor+0xac>
  4006f6:	2b02      	cmp	r3, #2
  4006f8:	dc31      	bgt.n	40075e <get_descriptor+0xca>
  4006fa:	2b00      	cmp	r3, #0
  4006fc:	d002      	beq.n	400704 <get_descriptor+0x70>
  4006fe:	2b01      	cmp	r3, #1
  400700:	d00f      	beq.n	400722 <get_descriptor+0x8e>
  400702:	e02c      	b.n	40075e <get_descriptor+0xca>
        case 0x00:
            send_usb_data(0, sd_lang_ID,
                setup->length.val_16 > lang_ID_desc_size ?
  400704:	687b      	ldr	r3, [r7, #4]
  400706:	88da      	ldrh	r2, [r3, #6]
  400708:	4b22      	ldr	r3, [pc, #136]	; (400794 <get_descriptor+0x100>)
  40070a:	781b      	ldrb	r3, [r3, #0]
  40070c:	b29b      	uxth	r3, r3
            send_usb_data(0, sd_lang_ID,
  40070e:	4293      	cmp	r3, r2
  400710:	bf28      	it	cs
  400712:	4613      	movcs	r3, r2
  400714:	b29b      	uxth	r3, r3
  400716:	461a      	mov	r2, r3
  400718:	491f      	ldr	r1, [pc, #124]	; (400798 <get_descriptor+0x104>)
  40071a:	2000      	movs	r0, #0
  40071c:	4b1a      	ldr	r3, [pc, #104]	; (400788 <get_descriptor+0xf4>)
  40071e:	4798      	blx	r3
                lang_ID_desc_size : setup->length.val_16);
            break;
  400720:	e023      	b.n	40076a <get_descriptor+0xd6>
        case 0x01:
            send_usb_data(0, sd_vendor,
                setup->length.val_16 > vendor_desc_size ?
  400722:	687b      	ldr	r3, [r7, #4]
  400724:	88da      	ldrh	r2, [r3, #6]
  400726:	4b1d      	ldr	r3, [pc, #116]	; (40079c <get_descriptor+0x108>)
  400728:	781b      	ldrb	r3, [r3, #0]
  40072a:	b29b      	uxth	r3, r3
            send_usb_data(0, sd_vendor,
  40072c:	4293      	cmp	r3, r2
  40072e:	bf28      	it	cs
  400730:	4613      	movcs	r3, r2
  400732:	b29b      	uxth	r3, r3
  400734:	461a      	mov	r2, r3
  400736:	491a      	ldr	r1, [pc, #104]	; (4007a0 <get_descriptor+0x10c>)
  400738:	2000      	movs	r0, #0
  40073a:	4b13      	ldr	r3, [pc, #76]	; (400788 <get_descriptor+0xf4>)
  40073c:	4798      	blx	r3
                vendor_desc_size : setup->length.val_16);
            break;
  40073e:	e014      	b.n	40076a <get_descriptor+0xd6>
        case 0x02:
            send_usb_data(0, sd_product,
                setup->length.val_16 > product_desc_size ?
  400740:	687b      	ldr	r3, [r7, #4]
  400742:	88da      	ldrh	r2, [r3, #6]
  400744:	4b17      	ldr	r3, [pc, #92]	; (4007a4 <get_descriptor+0x110>)
  400746:	781b      	ldrb	r3, [r3, #0]
  400748:	b29b      	uxth	r3, r3
            send_usb_data(0, sd_product,
  40074a:	4293      	cmp	r3, r2
  40074c:	bf28      	it	cs
  40074e:	4613      	movcs	r3, r2
  400750:	b29b      	uxth	r3, r3
  400752:	461a      	mov	r2, r3
  400754:	4914      	ldr	r1, [pc, #80]	; (4007a8 <get_descriptor+0x114>)
  400756:	2000      	movs	r0, #0
  400758:	4b0b      	ldr	r3, [pc, #44]	; (400788 <get_descriptor+0xf4>)
  40075a:	4798      	blx	r3
                product_desc_size : setup->length.val_16);
            break;
  40075c:	e005      	b.n	40076a <get_descriptor+0xd6>
        default:
            send_usb_data(0, 0, 0);
  40075e:	2200      	movs	r2, #0
  400760:	2100      	movs	r1, #0
  400762:	2000      	movs	r0, #0
  400764:	4b08      	ldr	r3, [pc, #32]	; (400788 <get_descriptor+0xf4>)
  400766:	4798      	blx	r3
        }
        break;
  400768:	e006      	b.n	400778 <get_descriptor+0xe4>
  40076a:	e005      	b.n	400778 <get_descriptor+0xe4>
    default:
        send_usb_data(0, 0, 0);
  40076c:	2200      	movs	r2, #0
  40076e:	2100      	movs	r1, #0
  400770:	2000      	movs	r0, #0
  400772:	4b05      	ldr	r3, [pc, #20]	; (400788 <get_descriptor+0xf4>)
  400774:	4798      	blx	r3
        break;
  400776:	bf00      	nop
    }
}
  400778:	bf00      	nop
  40077a:	3708      	adds	r7, #8
  40077c:	46bd      	mov	sp, r7
  40077e:	bd80      	pop	{r7, pc}
  400780:	00400d62 	.word	0x00400d62
  400784:	00400cac 	.word	0x00400cac
  400788:	00400551 	.word	0x00400551
  40078c:	00400d63 	.word	0x00400d63
  400790:	00400cc0 	.word	0x00400cc0
  400794:	00400d61 	.word	0x00400d61
  400798:	00400ca8 	.word	0x00400ca8
  40079c:	00400d5f 	.word	0x00400d5f
  4007a0:	00400c88 	.word	0x00400c88
  4007a4:	00400d60 	.word	0x00400d60
  4007a8:	00400ca0 	.word	0x00400ca0

004007ac <get_usb_data>:

static void get_usb_data(uint8_t ep_num) {
  4007ac:	b480      	push	{r7}
  4007ae:	b087      	sub	sp, #28
  4007b0:	af00      	add	r7, sp, #0
  4007b2:	4603      	mov	r3, r0
  4007b4:	71fb      	strb	r3, [r7, #7]
    uint16_t byte_count = USBHS->USBHS_DEVEPTISR[ep_num].bit.BYCT;
  4007b6:	4a21      	ldr	r2, [pc, #132]	; (40083c <get_usb_data+0x90>)
  4007b8:	79fb      	ldrb	r3, [r7, #7]
  4007ba:	334c      	adds	r3, #76	; 0x4c
  4007bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4007c0:	f3c3 530a 	ubfx	r3, r3, #20, #11
  4007c4:	b29b      	uxth	r3, r3
  4007c6:	82bb      	strh	r3, [r7, #20]
    uint8_t *destination = endpoints[ep_num].data_buf;
  4007c8:	79fa      	ldrb	r2, [r7, #7]
  4007ca:	491d      	ldr	r1, [pc, #116]	; (400840 <get_usb_data+0x94>)
  4007cc:	4613      	mov	r3, r2
  4007ce:	009b      	lsls	r3, r3, #2
  4007d0:	4413      	add	r3, r2
  4007d2:	009b      	lsls	r3, r3, #2
  4007d4:	440b      	add	r3, r1
  4007d6:	3308      	adds	r3, #8
  4007d8:	681b      	ldr	r3, [r3, #0]
  4007da:	613b      	str	r3, [r7, #16]
    uint8_t *source = endpoints[ep_num].fifo_addr;
  4007dc:	79fa      	ldrb	r2, [r7, #7]
  4007de:	4918      	ldr	r1, [pc, #96]	; (400840 <get_usb_data+0x94>)
  4007e0:	4613      	mov	r3, r2
  4007e2:	009b      	lsls	r3, r3, #2
  4007e4:	4413      	add	r3, r2
  4007e6:	009b      	lsls	r3, r3, #2
  4007e8:	440b      	add	r3, r1
  4007ea:	3304      	adds	r3, #4
  4007ec:	681b      	ldr	r3, [r3, #0]
  4007ee:	60fb      	str	r3, [r7, #12]

    for (uint16_t i = 0; i < byte_count; i++) {
  4007f0:	2300      	movs	r3, #0
  4007f2:	82fb      	strh	r3, [r7, #22]
  4007f4:	e00a      	b.n	40080c <get_usb_data+0x60>
        *(destination + i) = *(source + i);
  4007f6:	8afb      	ldrh	r3, [r7, #22]
  4007f8:	68fa      	ldr	r2, [r7, #12]
  4007fa:	441a      	add	r2, r3
  4007fc:	8afb      	ldrh	r3, [r7, #22]
  4007fe:	6939      	ldr	r1, [r7, #16]
  400800:	440b      	add	r3, r1
  400802:	7812      	ldrb	r2, [r2, #0]
  400804:	701a      	strb	r2, [r3, #0]
    for (uint16_t i = 0; i < byte_count; i++) {
  400806:	8afb      	ldrh	r3, [r7, #22]
  400808:	3301      	adds	r3, #1
  40080a:	82fb      	strh	r3, [r7, #22]
  40080c:	8afa      	ldrh	r2, [r7, #22]
  40080e:	8abb      	ldrh	r3, [r7, #20]
  400810:	429a      	cmp	r2, r3
  400812:	d3f0      	bcc.n	4007f6 <get_usb_data+0x4a>
    }

    endpoints[ep_num].data_len = byte_count & 0x0A;
  400814:	79fa      	ldrb	r2, [r7, #7]
  400816:	8abb      	ldrh	r3, [r7, #20]
  400818:	f003 030a 	and.w	r3, r3, #10
  40081c:	b298      	uxth	r0, r3
  40081e:	4908      	ldr	r1, [pc, #32]	; (400840 <get_usb_data+0x94>)
  400820:	4613      	mov	r3, r2
  400822:	009b      	lsls	r3, r3, #2
  400824:	4413      	add	r3, r2
  400826:	009b      	lsls	r3, r3, #2
  400828:	440b      	add	r3, r1
  40082a:	3310      	adds	r3, #16
  40082c:	4602      	mov	r2, r0
  40082e:	801a      	strh	r2, [r3, #0]
}
  400830:	bf00      	nop
  400832:	371c      	adds	r7, #28
  400834:	46bd      	mov	sp, r7
  400836:	bc80      	pop	{r7}
  400838:	4770      	bx	lr
  40083a:	bf00      	nop
  40083c:	40038000 	.word	0x40038000
  400840:	20400000 	.word	0x20400000

00400844 <handle_ep_req>:

static void handle_ep_req(setup_packet_t *packet){
  400844:	b580      	push	{r7, lr}
  400846:	b082      	sub	sp, #8
  400848:	af00      	add	r7, sp, #0
  40084a:	6078      	str	r0, [r7, #4]
    switch (packet->request)
  40084c:	687b      	ldr	r3, [r7, #4]
  40084e:	785b      	ldrb	r3, [r3, #1]
  400850:	2b0c      	cmp	r3, #12
  400852:	d82f      	bhi.n	4008b4 <handle_ep_req+0x70>
  400854:	a201      	add	r2, pc, #4	; (adr r2, 40085c <handle_ep_req+0x18>)
  400856:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40085a:	bf00      	nop
  40085c:	00400891 	.word	0x00400891
  400860:	0040089d 	.word	0x0040089d
  400864:	004008b5 	.word	0x004008b5
  400868:	004008a9 	.word	0x004008a9
  40086c:	004008b5 	.word	0x004008b5
  400870:	004008b5 	.word	0x004008b5
  400874:	004008b5 	.word	0x004008b5
  400878:	004008b5 	.word	0x004008b5
  40087c:	004008b5 	.word	0x004008b5
  400880:	004008b5 	.word	0x004008b5
  400884:	004008b5 	.word	0x004008b5
  400888:	004008b5 	.word	0x004008b5
  40088c:	004008b5 	.word	0x004008b5
    {
    case USB_REQUEST_GET_STATUS:
        send_usb_data(0, 0, 0);
  400890:	2200      	movs	r2, #0
  400892:	2100      	movs	r1, #0
  400894:	2000      	movs	r0, #0
  400896:	4b0a      	ldr	r3, [pc, #40]	; (4008c0 <handle_ep_req+0x7c>)
  400898:	4798      	blx	r3
        break;
  40089a:	e00c      	b.n	4008b6 <handle_ep_req+0x72>
    case USB_REQUEST_CLEAR_FEATURE:
        send_usb_data(0, 0, 0);
  40089c:	2200      	movs	r2, #0
  40089e:	2100      	movs	r1, #0
  4008a0:	2000      	movs	r0, #0
  4008a2:	4b07      	ldr	r3, [pc, #28]	; (4008c0 <handle_ep_req+0x7c>)
  4008a4:	4798      	blx	r3
        break;
  4008a6:	e006      	b.n	4008b6 <handle_ep_req+0x72>
    case USB_REQUEST_SET_FEATURE:
        send_usb_data(0, 0, 0);
  4008a8:	2200      	movs	r2, #0
  4008aa:	2100      	movs	r1, #0
  4008ac:	2000      	movs	r0, #0
  4008ae:	4b04      	ldr	r3, [pc, #16]	; (4008c0 <handle_ep_req+0x7c>)
  4008b0:	4798      	blx	r3
        break;
  4008b2:	e000      	b.n	4008b6 <handle_ep_req+0x72>
    case USB_REQUEST_SYNC_FRAME:
        break;
    default:
        break;
  4008b4:	bf00      	nop
    }
}
  4008b6:	bf00      	nop
  4008b8:	3708      	adds	r7, #8
  4008ba:	46bd      	mov	sp, r7
  4008bc:	bd80      	pop	{r7, pc}
  4008be:	bf00      	nop
  4008c0:	00400551 	.word	0x00400551

004008c4 <handle_interface_req>:

static void handle_interface_req(setup_packet_t *packet){
  4008c4:	b580      	push	{r7, lr}
  4008c6:	b082      	sub	sp, #8
  4008c8:	af00      	add	r7, sp, #0
  4008ca:	6078      	str	r0, [r7, #4]
    switch (packet->request)
  4008cc:	687b      	ldr	r3, [r7, #4]
  4008ce:	785b      	ldrb	r3, [r3, #1]
  4008d0:	2b0b      	cmp	r3, #11
  4008d2:	d838      	bhi.n	400946 <handle_interface_req+0x82>
  4008d4:	a201      	add	r2, pc, #4	; (adr r2, 4008dc <handle_interface_req+0x18>)
  4008d6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4008da:	bf00      	nop
  4008dc:	0040090d 	.word	0x0040090d
  4008e0:	00400919 	.word	0x00400919
  4008e4:	00400947 	.word	0x00400947
  4008e8:	00400925 	.word	0x00400925
  4008ec:	00400947 	.word	0x00400947
  4008f0:	00400947 	.word	0x00400947
  4008f4:	00400947 	.word	0x00400947
  4008f8:	00400947 	.word	0x00400947
  4008fc:	00400947 	.word	0x00400947
  400900:	00400947 	.word	0x00400947
  400904:	00400931 	.word	0x00400931
  400908:	0040093d 	.word	0x0040093d
    {
    case USB_REQUEST_GET_STATUS:
        send_usb_data(0, 0, 0);
  40090c:	2200      	movs	r2, #0
  40090e:	2100      	movs	r1, #0
  400910:	2000      	movs	r0, #0
  400912:	4b0f      	ldr	r3, [pc, #60]	; (400950 <handle_interface_req+0x8c>)
  400914:	4798      	blx	r3
        break;
  400916:	e017      	b.n	400948 <handle_interface_req+0x84>
    case USB_REQUEST_CLEAR_FEATURE:
        send_usb_data(0, 0, 0);
  400918:	2200      	movs	r2, #0
  40091a:	2100      	movs	r1, #0
  40091c:	2000      	movs	r0, #0
  40091e:	4b0c      	ldr	r3, [pc, #48]	; (400950 <handle_interface_req+0x8c>)
  400920:	4798      	blx	r3
        break;
  400922:	e011      	b.n	400948 <handle_interface_req+0x84>
    case USB_REQUEST_SET_FEATURE:
        send_usb_data(0, 0, 0);
  400924:	2200      	movs	r2, #0
  400926:	2100      	movs	r1, #0
  400928:	2000      	movs	r0, #0
  40092a:	4b09      	ldr	r3, [pc, #36]	; (400950 <handle_interface_req+0x8c>)
  40092c:	4798      	blx	r3
        break;
  40092e:	e00b      	b.n	400948 <handle_interface_req+0x84>
    case USB_REQUEST_GET_INTERFACE:
        send_usb_data(0, 0, 0);
  400930:	2200      	movs	r2, #0
  400932:	2100      	movs	r1, #0
  400934:	2000      	movs	r0, #0
  400936:	4b06      	ldr	r3, [pc, #24]	; (400950 <handle_interface_req+0x8c>)
  400938:	4798      	blx	r3
        break;
  40093a:	e005      	b.n	400948 <handle_interface_req+0x84>
    case USB_REQUEST_SET_INTERFACE:
        send_usb_data(0, 0, 0);
  40093c:	2200      	movs	r2, #0
  40093e:	2100      	movs	r1, #0
  400940:	2000      	movs	r0, #0
  400942:	4b03      	ldr	r3, [pc, #12]	; (400950 <handle_interface_req+0x8c>)
  400944:	4798      	blx	r3
    default:
        break;
  400946:	bf00      	nop
    }
}
  400948:	bf00      	nop
  40094a:	3708      	adds	r7, #8
  40094c:	46bd      	mov	sp, r7
  40094e:	bd80      	pop	{r7, pc}
  400950:	00400551 	.word	0x00400551

00400954 <handle_device_req>:

static void handle_device_req(setup_packet_t *packet){
  400954:	b580      	push	{r7, lr}
  400956:	b082      	sub	sp, #8
  400958:	af00      	add	r7, sp, #0
  40095a:	6078      	str	r0, [r7, #4]
    switch (packet->request)
  40095c:	687b      	ldr	r3, [r7, #4]
  40095e:	785b      	ldrb	r3, [r3, #1]
  400960:	2b09      	cmp	r3, #9
  400962:	d84a      	bhi.n	4009fa <handle_device_req+0xa6>
  400964:	a201      	add	r2, pc, #4	; (adr r2, 40096c <handle_device_req+0x18>)
  400966:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40096a:	bf00      	nop
  40096c:	004009fb 	.word	0x004009fb
  400970:	00400995 	.word	0x00400995
  400974:	004009fb 	.word	0x004009fb
  400978:	004009fb 	.word	0x004009fb
  40097c:	004009fb 	.word	0x004009fb
  400980:	004009a1 	.word	0x004009a1
  400984:	004009d5 	.word	0x004009d5
  400988:	004009fb 	.word	0x004009fb
  40098c:	004009dd 	.word	0x004009dd
  400990:	004009e9 	.word	0x004009e9
    {
    case USB_REQUEST_GET_STATUS:
        break;
    case USB_REQUEST_CLEAR_FEATURE:
        send_usb_data(0, 0, 0);
  400994:	2200      	movs	r2, #0
  400996:	2100      	movs	r1, #0
  400998:	2000      	movs	r0, #0
  40099a:	4b1a      	ldr	r3, [pc, #104]	; (400a04 <handle_device_req+0xb0>)
  40099c:	4798      	blx	r3
        break;
  40099e:	e02d      	b.n	4009fc <handle_device_req+0xa8>
    case USB_REQUEST_SET_FEATURE:
        break;
    case USB_REQUEST_SET_ADDRESS:
        USBHS->USBHS_DEVCTRL.bit.UADD = packet->value.val_16;
  4009a0:	687b      	ldr	r3, [r7, #4]
  4009a2:	885b      	ldrh	r3, [r3, #2]
  4009a4:	4a18      	ldr	r2, [pc, #96]	; (400a08 <handle_device_req+0xb4>)
  4009a6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  4009aa:	b2d9      	uxtb	r1, r3
  4009ac:	6813      	ldr	r3, [r2, #0]
  4009ae:	f361 0306 	bfi	r3, r1, #0, #7
  4009b2:	6013      	str	r3, [r2, #0]
        USBHS->USBHS_DEVCTRL.bit.ADDEN = 0;
  4009b4:	4a14      	ldr	r2, [pc, #80]	; (400a08 <handle_device_req+0xb4>)
  4009b6:	6813      	ldr	r3, [r2, #0]
  4009b8:	f36f 13c7 	bfc	r3, #7, #1
  4009bc:	6013      	str	r3, [r2, #0]
        send_usb_data(0, 0, 0);
  4009be:	2200      	movs	r2, #0
  4009c0:	2100      	movs	r1, #0
  4009c2:	2000      	movs	r0, #0
  4009c4:	4b0f      	ldr	r3, [pc, #60]	; (400a04 <handle_device_req+0xb0>)
  4009c6:	4798      	blx	r3
        USBHS->USBHS_DEVCTRL.bit.ADDEN = 1;
  4009c8:	4a0f      	ldr	r2, [pc, #60]	; (400a08 <handle_device_req+0xb4>)
  4009ca:	6813      	ldr	r3, [r2, #0]
  4009cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  4009d0:	6013      	str	r3, [r2, #0]
        break;
  4009d2:	e013      	b.n	4009fc <handle_device_req+0xa8>
    case USB_REQUEST_GET_DESCRIPTOR:
        get_descriptor(packet);
  4009d4:	6878      	ldr	r0, [r7, #4]
  4009d6:	4b0d      	ldr	r3, [pc, #52]	; (400a0c <handle_device_req+0xb8>)
  4009d8:	4798      	blx	r3
        break;
  4009da:	e00f      	b.n	4009fc <handle_device_req+0xa8>
    case USB_REQUEST_SET_DESCRIPTOR:
        break;
    case USB_REQUEST_GET_CONFIGURATION:
		send_usb_data(0, &dev_configured, 1);
  4009dc:	2201      	movs	r2, #1
  4009de:	490c      	ldr	r1, [pc, #48]	; (400a10 <handle_device_req+0xbc>)
  4009e0:	2000      	movs	r0, #0
  4009e2:	4b08      	ldr	r3, [pc, #32]	; (400a04 <handle_device_req+0xb0>)
  4009e4:	4798      	blx	r3
        break;
  4009e6:	e009      	b.n	4009fc <handle_device_req+0xa8>
    case USB_REQUEST_SET_CONFIGURATION:
        dev_configured = 1;
  4009e8:	4b09      	ldr	r3, [pc, #36]	; (400a10 <handle_device_req+0xbc>)
  4009ea:	2201      	movs	r2, #1
  4009ec:	701a      	strb	r2, [r3, #0]
        send_usb_data(0, 0, 0);
  4009ee:	2200      	movs	r2, #0
  4009f0:	2100      	movs	r1, #0
  4009f2:	2000      	movs	r0, #0
  4009f4:	4b03      	ldr	r3, [pc, #12]	; (400a04 <handle_device_req+0xb0>)
  4009f6:	4798      	blx	r3
        break;
  4009f8:	e000      	b.n	4009fc <handle_device_req+0xa8>
    default:
        break;
  4009fa:	bf00      	nop
    }
}
  4009fc:	bf00      	nop
  4009fe:	3708      	adds	r7, #8
  400a00:	46bd      	mov	sp, r7
  400a02:	bd80      	pop	{r7, pc}
  400a04:	00400551 	.word	0x00400551
  400a08:	40038000 	.word	0x40038000
  400a0c:	00400695 	.word	0x00400695
  400a10:	204001e4 	.word	0x204001e4

00400a14 <handle_status_packet>:

static void handle_status_packet(setup_packet_t *setup){
  400a14:	b580      	push	{r7, lr}
  400a16:	b082      	sub	sp, #8
  400a18:	af00      	add	r7, sp, #0
  400a1a:	6078      	str	r0, [r7, #4]

    if(setup->request_type & USB_EP_REQ_MASK){
  400a1c:	687b      	ldr	r3, [r7, #4]
  400a1e:	781b      	ldrb	r3, [r3, #0]
  400a20:	f003 0302 	and.w	r3, r3, #2
  400a24:	2b00      	cmp	r3, #0
  400a26:	d003      	beq.n	400a30 <handle_status_packet+0x1c>
        handle_ep_req(setup);
  400a28:	6878      	ldr	r0, [r7, #4]
  400a2a:	4b0a      	ldr	r3, [pc, #40]	; (400a54 <handle_status_packet+0x40>)
  400a2c:	4798      	blx	r3
        handle_interface_req(setup);
    }
    else{
        handle_device_req(setup);
    }
}
  400a2e:	e00c      	b.n	400a4a <handle_status_packet+0x36>
    else if(setup->request_type & USB_INTERFACE_REQ_MASK){
  400a30:	687b      	ldr	r3, [r7, #4]
  400a32:	781b      	ldrb	r3, [r3, #0]
  400a34:	f003 0301 	and.w	r3, r3, #1
  400a38:	2b00      	cmp	r3, #0
  400a3a:	d003      	beq.n	400a44 <handle_status_packet+0x30>
        handle_interface_req(setup);
  400a3c:	6878      	ldr	r0, [r7, #4]
  400a3e:	4b06      	ldr	r3, [pc, #24]	; (400a58 <handle_status_packet+0x44>)
  400a40:	4798      	blx	r3
}
  400a42:	e002      	b.n	400a4a <handle_status_packet+0x36>
        handle_device_req(setup);
  400a44:	6878      	ldr	r0, [r7, #4]
  400a46:	4b05      	ldr	r3, [pc, #20]	; (400a5c <handle_status_packet+0x48>)
  400a48:	4798      	blx	r3
}
  400a4a:	bf00      	nop
  400a4c:	3708      	adds	r7, #8
  400a4e:	46bd      	mov	sp, r7
  400a50:	bd80      	pop	{r7, pc}
  400a52:	bf00      	nop
  400a54:	00400845 	.word	0x00400845
  400a58:	004008c5 	.word	0x004008c5
  400a5c:	00400955 	.word	0x00400955

00400a60 <handle_control_ep>:
static void handle_control_data(void){
    USBHS->USBHS_DEVEPTICR[0].bit.RXOUTIC = 1;
    return;
}

static void handle_control_ep(void) {
  400a60:	b580      	push	{r7, lr}
  400a62:	b082      	sub	sp, #8
  400a64:	af00      	add	r7, sp, #0
    get_usb_data(0);
  400a66:	2000      	movs	r0, #0
  400a68:	4b15      	ldr	r3, [pc, #84]	; (400ac0 <handle_control_ep+0x60>)
  400a6a:	4798      	blx	r3
    setup_packet_t setup = parse_setup_packet(0);
  400a6c:	463b      	mov	r3, r7
  400a6e:	2100      	movs	r1, #0
  400a70:	4618      	mov	r0, r3
  400a72:	4b14      	ldr	r3, [pc, #80]	; (400ac4 <handle_control_ep+0x64>)
  400a74:	4798      	blx	r3
    USBHS->USBHS_DEVEPTICR[0].bit.RXSTPIC = 1;
  400a76:	4a14      	ldr	r2, [pc, #80]	; (400ac8 <handle_control_ep+0x68>)
  400a78:	f8d2 3160 	ldr.w	r3, [r2, #352]	; 0x160
  400a7c:	f043 0304 	orr.w	r3, r3, #4
  400a80:	f8c2 3160 	str.w	r3, [r2, #352]	; 0x160
    USBHS->USBHS_DEVEPTICR[0].bit.RXOUTIC = 1;
  400a84:	4a10      	ldr	r2, [pc, #64]	; (400ac8 <handle_control_ep+0x68>)
  400a86:	f8d2 3160 	ldr.w	r3, [r2, #352]	; 0x160
  400a8a:	f043 0302 	orr.w	r3, r3, #2
  400a8e:	f8c2 3160 	str.w	r3, [r2, #352]	; 0x160

    if(setup.request_type & USB_REQ_TYPE_CLASS){
  400a92:	783b      	ldrb	r3, [r7, #0]
  400a94:	f003 0320 	and.w	r3, r3, #32
  400a98:	2b00      	cmp	r3, #0
  400a9a:	d002      	beq.n	400aa2 <handle_control_ep+0x42>
        handle_aud_ctr_ep();
  400a9c:	4b0b      	ldr	r3, [pc, #44]	; (400acc <handle_control_ep+0x6c>)
  400a9e:	4798      	blx	r3
  400aa0:	e006      	b.n	400ab0 <handle_control_ep+0x50>
    }
    else if(setup.request_type & USB_REQ_TYPE_VENDOR){
  400aa2:	783b      	ldrb	r3, [r7, #0]
  400aa4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  400aa8:	2b00      	cmp	r3, #0
  400aaa:	d001      	beq.n	400ab0 <handle_control_ep+0x50>
        handle_aud_ctr_ep();
  400aac:	4b07      	ldr	r3, [pc, #28]	; (400acc <handle_control_ep+0x6c>)
  400aae:	4798      	blx	r3
    }
    handle_status_packet(&setup);
  400ab0:	463b      	mov	r3, r7
  400ab2:	4618      	mov	r0, r3
  400ab4:	4b06      	ldr	r3, [pc, #24]	; (400ad0 <handle_control_ep+0x70>)
  400ab6:	4798      	blx	r3
}
  400ab8:	bf00      	nop
  400aba:	3708      	adds	r7, #8
  400abc:	46bd      	mov	sp, r7
  400abe:	bd80      	pop	{r7, pc}
  400ac0:	004007ad 	.word	0x004007ad
  400ac4:	004004d5 	.word	0x004004d5
  400ac8:	40038000 	.word	0x40038000
  400acc:	004004c7 	.word	0x004004c7
  400ad0:	00400a15 	.word	0x00400a15

00400ad4 <init_endpoints>:

static uint8_t init_endpoints(void) {
  400ad4:	b480      	push	{r7}
  400ad6:	af00      	add	r7, sp, #0
    USBHS->USBHS_DEVEPT.bit.EPEN1 = 1;
  400ad8:	4a30      	ldr	r2, [pc, #192]	; (400b9c <init_endpoints+0xc8>)
  400ada:	69d3      	ldr	r3, [r2, #28]
  400adc:	f043 0302 	orr.w	r3, r3, #2
  400ae0:	61d3      	str	r3, [r2, #28]
    USBHS->USBHS_DEVEPTCFG[1].reg |= USBHS_DEVEPTCFG_EPTYPE_INTRPT |
  400ae2:	4b2e      	ldr	r3, [pc, #184]	; (400b9c <init_endpoints+0xc8>)
  400ae4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
  400ae8:	4a2c      	ldr	r2, [pc, #176]	; (400b9c <init_endpoints+0xc8>)
  400aea:	f443 53c8 	orr.w	r3, r3, #6400	; 0x1900
  400aee:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
        USBHS_DEVEPTCFG_EPSIZE_8_BYTE |
        USBHS_DEVEPTCFG_EPDIR_IN |
        USBHS_DEVEPTCFG_EPBK_1_BANK;

    USBHS->USBHS_DEVEPTCFG[1].reg |= USBHS_DEVEPTCFG_ALLOC;
  400af2:	4b2a      	ldr	r3, [pc, #168]	; (400b9c <init_endpoints+0xc8>)
  400af4:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
  400af8:	4a28      	ldr	r2, [pc, #160]	; (400b9c <init_endpoints+0xc8>)
  400afa:	f043 0302 	orr.w	r3, r3, #2
  400afe:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
    if (!USBHS->USBHS_DEVEPTISR[1].bit.CFGOK) {
  400b02:	4b26      	ldr	r3, [pc, #152]	; (400b9c <init_endpoints+0xc8>)
  400b04:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
  400b08:	f3c3 4380 	ubfx	r3, r3, #18, #1
  400b0c:	b2db      	uxtb	r3, r3
  400b0e:	2b00      	cmp	r3, #0
  400b10:	d101      	bne.n	400b16 <init_endpoints+0x42>
        return 1;
  400b12:	2301      	movs	r3, #1
  400b14:	e03e      	b.n	400b94 <init_endpoints+0xc0>
    }

    USBHS->USBHS_DEVEPT.bit.EPEN2 = 1;
  400b16:	4a21      	ldr	r2, [pc, #132]	; (400b9c <init_endpoints+0xc8>)
  400b18:	69d3      	ldr	r3, [r2, #28]
  400b1a:	f043 0304 	orr.w	r3, r3, #4
  400b1e:	61d3      	str	r3, [r2, #28]
    USBHS->USBHS_DEVEPTCFG[2].reg |= USBHS_DEVEPTCFG_EPTYPE_ISO |
  400b20:	4b1e      	ldr	r3, [pc, #120]	; (400b9c <init_endpoints+0xc8>)
  400b22:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  400b26:	491d      	ldr	r1, [pc, #116]	; (400b9c <init_endpoints+0xc8>)
  400b28:	f640 0358 	movw	r3, #2136	; 0x858
  400b2c:	4313      	orrs	r3, r2
  400b2e:	f8c1 3108 	str.w	r3, [r1, #264]	; 0x108
        USBHS_DEVEPTCFG_EPSIZE_256_BYTE |
        USBHS_DEVEPTCFG_EPDIR_OUT |
        USBHS_DEVEPTCFG_EPBK_3_BANK;

    USBHS->USBHS_DEVEPTCFG[2].reg |= USBHS_DEVEPTCFG_ALLOC;
  400b32:	4b1a      	ldr	r3, [pc, #104]	; (400b9c <init_endpoints+0xc8>)
  400b34:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
  400b38:	4a18      	ldr	r2, [pc, #96]	; (400b9c <init_endpoints+0xc8>)
  400b3a:	f043 0302 	orr.w	r3, r3, #2
  400b3e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    if (!USBHS->USBHS_DEVEPTISR[2].bit.CFGOK) {
  400b42:	4b16      	ldr	r3, [pc, #88]	; (400b9c <init_endpoints+0xc8>)
  400b44:	f8d3 3138 	ldr.w	r3, [r3, #312]	; 0x138
  400b48:	f3c3 4380 	ubfx	r3, r3, #18, #1
  400b4c:	b2db      	uxtb	r3, r3
  400b4e:	2b00      	cmp	r3, #0
  400b50:	d101      	bne.n	400b56 <init_endpoints+0x82>
        return 1;
  400b52:	2301      	movs	r3, #1
  400b54:	e01e      	b.n	400b94 <init_endpoints+0xc0>
    }

    USBHS->USBHS_DEVEPT.bit.EPEN3 = 1;
  400b56:	4a11      	ldr	r2, [pc, #68]	; (400b9c <init_endpoints+0xc8>)
  400b58:	69d3      	ldr	r3, [r2, #28]
  400b5a:	f043 0308 	orr.w	r3, r3, #8
  400b5e:	61d3      	str	r3, [r2, #28]
    USBHS->USBHS_DEVEPTCFG[3].reg |= USBHS_DEVEPTCFG_EPTYPE_ISO |
  400b60:	4b0e      	ldr	r3, [pc, #56]	; (400b9c <init_endpoints+0xc8>)
  400b62:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
  400b66:	4a0d      	ldr	r2, [pc, #52]	; (400b9c <init_endpoints+0xc8>)
  400b68:	f443 6310 	orr.w	r3, r3, #2304	; 0x900
  400b6c:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
        USBHS_DEVEPTCFG_EPSIZE_8_BYTE |
        USBHS_DEVEPTCFG_EPDIR_IN |
        USBHS_DEVEPTCFG_EPBK_1_BANK;

    USBHS->USBHS_DEVEPTCFG[3].reg |= USBHS_DEVEPTCFG_ALLOC;
  400b70:	4b0a      	ldr	r3, [pc, #40]	; (400b9c <init_endpoints+0xc8>)
  400b72:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
  400b76:	4a09      	ldr	r2, [pc, #36]	; (400b9c <init_endpoints+0xc8>)
  400b78:	f043 0302 	orr.w	r3, r3, #2
  400b7c:	f8c2 310c 	str.w	r3, [r2, #268]	; 0x10c
    if (!USBHS->USBHS_DEVEPTISR[3].bit.CFGOK) {
  400b80:	4b06      	ldr	r3, [pc, #24]	; (400b9c <init_endpoints+0xc8>)
  400b82:	f8d3 313c 	ldr.w	r3, [r3, #316]	; 0x13c
  400b86:	f3c3 4380 	ubfx	r3, r3, #18, #1
  400b8a:	b2db      	uxtb	r3, r3
  400b8c:	2b00      	cmp	r3, #0
  400b8e:	d101      	bne.n	400b94 <init_endpoints+0xc0>
        return 1;
  400b90:	2301      	movs	r3, #1
  400b92:	e7ff      	b.n	400b94 <init_endpoints+0xc0>
    }
}
  400b94:	4618      	mov	r0, r3
  400b96:	46bd      	mov	sp, r7
  400b98:	bc80      	pop	{r7}
  400b9a:	4770      	bx	lr
  400b9c:	40038000 	.word	0x40038000

00400ba0 <usb_wakeup_handler>:

static void usb_wakeup_handler(void){
  400ba0:	b580      	push	{r7, lr}
  400ba2:	af00      	add	r7, sp, #0
    USBHS->USBHS_DEVEPTIER[0].reg |= USBHS_DEVEPTIER_RXSTPES | USBHS_DEVEPTIER_RXOUTES;
  400ba4:	4b1e      	ldr	r3, [pc, #120]	; (400c20 <usb_wakeup_handler+0x80>)
  400ba6:	f8d3 31f0 	ldr.w	r3, [r3, #496]	; 0x1f0
  400baa:	4a1d      	ldr	r2, [pc, #116]	; (400c20 <usb_wakeup_handler+0x80>)
  400bac:	f043 0306 	orr.w	r3, r3, #6
  400bb0:	f8c2 31f0 	str.w	r3, [r2, #496]	; 0x1f0
    USBHS->USBHS_DEVIER.bit.PEP_0 = 1;
  400bb4:	4a1a      	ldr	r2, [pc, #104]	; (400c20 <usb_wakeup_handler+0x80>)
  400bb6:	6993      	ldr	r3, [r2, #24]
  400bb8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  400bbc:	6193      	str	r3, [r2, #24]

    USBHS->USBHS_DEVEPTIER[1].reg |= USBHS_DEVEPTIER_RXSTPES | USBHS_DEVEPTIER_RXOUTES;
  400bbe:	4b18      	ldr	r3, [pc, #96]	; (400c20 <usb_wakeup_handler+0x80>)
  400bc0:	f8d3 31f4 	ldr.w	r3, [r3, #500]	; 0x1f4
  400bc4:	4a16      	ldr	r2, [pc, #88]	; (400c20 <usb_wakeup_handler+0x80>)
  400bc6:	f043 0306 	orr.w	r3, r3, #6
  400bca:	f8c2 31f4 	str.w	r3, [r2, #500]	; 0x1f4
    USBHS->USBHS_DEVIER.bit.PEP_1 = 1;
  400bce:	4a14      	ldr	r2, [pc, #80]	; (400c20 <usb_wakeup_handler+0x80>)
  400bd0:	6993      	ldr	r3, [r2, #24]
  400bd2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  400bd6:	6193      	str	r3, [r2, #24]

    USBHS->USBHS_DEVEPTIER[2].reg |= USBHS_DEVEPTIER_RXSTPES | USBHS_DEVEPTIER_RXOUTES;
  400bd8:	4b11      	ldr	r3, [pc, #68]	; (400c20 <usb_wakeup_handler+0x80>)
  400bda:	f8d3 31f8 	ldr.w	r3, [r3, #504]	; 0x1f8
  400bde:	4a10      	ldr	r2, [pc, #64]	; (400c20 <usb_wakeup_handler+0x80>)
  400be0:	f043 0306 	orr.w	r3, r3, #6
  400be4:	f8c2 31f8 	str.w	r3, [r2, #504]	; 0x1f8
    USBHS->USBHS_DEVIER.bit.PEP_2 = 1;
  400be8:	4a0d      	ldr	r2, [pc, #52]	; (400c20 <usb_wakeup_handler+0x80>)
  400bea:	6993      	ldr	r3, [r2, #24]
  400bec:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  400bf0:	6193      	str	r3, [r2, #24]

    USBHS->USBHS_DEVEPTIER[3].reg |= USBHS_DEVEPTIER_RXSTPES | USBHS_DEVEPTIER_RXOUTES;
  400bf2:	4b0b      	ldr	r3, [pc, #44]	; (400c20 <usb_wakeup_handler+0x80>)
  400bf4:	f8d3 31fc 	ldr.w	r3, [r3, #508]	; 0x1fc
  400bf8:	4a09      	ldr	r2, [pc, #36]	; (400c20 <usb_wakeup_handler+0x80>)
  400bfa:	f043 0306 	orr.w	r3, r3, #6
  400bfe:	f8c2 31fc 	str.w	r3, [r2, #508]	; 0x1fc
    USBHS->USBHS_DEVIER.bit.PEP_3 = 1;
  400c02:	4a07      	ldr	r2, [pc, #28]	; (400c20 <usb_wakeup_handler+0x80>)
  400c04:	6993      	ldr	r3, [r2, #24]
  400c06:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400c0a:	6193      	str	r3, [r2, #24]

    init_endpoints();
  400c0c:	4b05      	ldr	r3, [pc, #20]	; (400c24 <usb_wakeup_handler+0x84>)
  400c0e:	4798      	blx	r3

    USBHS->USBHS_DEVICR.reg |= USBHS_DEVICR_WAKEUPC | USBHS_DEVICR_EORSTC;
  400c10:	4b03      	ldr	r3, [pc, #12]	; (400c20 <usb_wakeup_handler+0x80>)
  400c12:	689b      	ldr	r3, [r3, #8]
  400c14:	4a02      	ldr	r2, [pc, #8]	; (400c20 <usb_wakeup_handler+0x80>)
  400c16:	f043 0318 	orr.w	r3, r3, #24
  400c1a:	6093      	str	r3, [r2, #8]
}
  400c1c:	bf00      	nop
  400c1e:	bd80      	pop	{r7, pc}
  400c20:	40038000 	.word	0x40038000
  400c24:	00400ad5 	.word	0x00400ad5

00400c28 <irq_handler_usbhs>:

    NVIC_EnableIRQ(USBHS_IRQn);
    NVIC_SetPriority(USBHS_IRQn, 1);
}

void irq_handler_usbhs(void) {
  400c28:	b580      	push	{r7, lr}
  400c2a:	b082      	sub	sp, #8
  400c2c:	af00      	add	r7, sp, #0
    uint32_t isr_reg = USBHS->USBHS_DEVISR.reg;
  400c2e:	4b11      	ldr	r3, [pc, #68]	; (400c74 <irq_handler_usbhs+0x4c>)
  400c30:	685b      	ldr	r3, [r3, #4]
  400c32:	607b      	str	r3, [r7, #4]
    if(isr_reg & USBHS_DEVISR_WAKEUP){
  400c34:	687b      	ldr	r3, [r7, #4]
  400c36:	f003 0310 	and.w	r3, r3, #16
  400c3a:	2b00      	cmp	r3, #0
  400c3c:	d001      	beq.n	400c42 <irq_handler_usbhs+0x1a>
        usb_wakeup_handler();
  400c3e:	4b0e      	ldr	r3, [pc, #56]	; (400c78 <irq_handler_usbhs+0x50>)
  400c40:	4798      	blx	r3
    }
    if (isr_reg & USBHS_DEVISR_PEP_0) {
  400c42:	687b      	ldr	r3, [r7, #4]
  400c44:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  400c48:	2b00      	cmp	r3, #0
  400c4a:	d001      	beq.n	400c50 <irq_handler_usbhs+0x28>
        handle_control_ep();
  400c4c:	4b0b      	ldr	r3, [pc, #44]	; (400c7c <irq_handler_usbhs+0x54>)
  400c4e:	4798      	blx	r3
    }
    if (isr_reg & USBHS_DEVISR_PEP_1){
  400c50:	687b      	ldr	r3, [r7, #4]
  400c52:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  400c56:	2b00      	cmp	r3, #0
  400c58:	d001      	beq.n	400c5e <irq_handler_usbhs+0x36>
        handle_aud_ctr_ep();
  400c5a:	4b09      	ldr	r3, [pc, #36]	; (400c80 <irq_handler_usbhs+0x58>)
  400c5c:	4798      	blx	r3
    }
    if (isr_reg & USBHS_DEVISR_PEP_2){
  400c5e:	687b      	ldr	r3, [r7, #4]
  400c60:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  400c64:	2b00      	cmp	r3, #0
  400c66:	d001      	beq.n	400c6c <irq_handler_usbhs+0x44>
        handle_aud_ctr_ep();
  400c68:	4b05      	ldr	r3, [pc, #20]	; (400c80 <irq_handler_usbhs+0x58>)
  400c6a:	4798      	blx	r3
    }
}
  400c6c:	bf00      	nop
  400c6e:	3708      	adds	r7, #8
  400c70:	46bd      	mov	sp, r7
  400c72:	bd80      	pop	{r7, pc}
  400c74:	40038000 	.word	0x40038000
  400c78:	00400ba1 	.word	0x00400ba1
  400c7c:	00400a61 	.word	0x00400a61
  400c80:	004004c7 	.word	0x004004c7
  400c84:	00636261 	.word	0x00636261

00400c88 <sd_vendor>:
  400c88:	00420318 00610072 0064006e 006e006f     ..B.r.a.n.d.o.n.
  400c98:	00480020 006f0061                        .H.a.o.

00400ca0 <sd_product>:
  400ca0:	00440308 00430041                       ..D.A.C.

00400ca8 <sd_lang_ID>:
  400ca8:	04090304                                ....

00400cac <dev_desc>:
  400cac:	02000112 400102ef 00010001 02010001     .......@........
  400cbc:	ffff0100                                ....

00400cc0 <config_desc>:
  400cc0:	009f0209 80000102 000b0832 20000102     ........2...... 
  400cd0:	00040900 01010100 24090020 0a020001     ........ ..$....
  400ce0:	11000047 01010224 00040001 00000000     G...$...........
  400cf0:	00004000 0203240c 03000301 00000004     .@...$..........
  400d00:	03062412 00000302 00000000 00000000     .$..............
  400d10:	24080000 0703040a 05070000 00060381     ...$............
  400d20:	01040904 02010000 04090020 01020101     ........ .......
  400d30:	10002002 05010124 00000101 00030200     . ..$...........
  400d40:	06000000 02010224 02050710 01006805     ....$........h..
  400d50:	00012508 00000000 11830507 18040004              .%.............

00400d5f <vendor_desc_size>:
  400d5f:	12040818                                         .

00400d60 <product_desc_size>:
  400d60:	9f120408                                         .

00400d61 <lang_ID_desc_size>:
  400d61:	009f1204                                         .

00400d62 <dev_desc_size>:
  400d62:	00009f12                                         .

00400d63 <config_desc_size>:
  400d63:	0000009f                                         .
